<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="" />
    <meta name="author" content="" />
    <!--[if IE]>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <![endif]-->
    <title>刘佳兴的个人网站</title>
    <!-- BOOTSTRAP CORE STYLE -->
    <link href="/assets/css/bootstrap.css" rel="stylesheet" />
    <!-- FONT AWESOME ICON STYLE -->
    <link href="/assets/css/font-awesome.css" rel="stylesheet" />
    <!-- CUSTOM STYLE CSS -->
    <link href="/assets/css/style.css" rel="stylesheet" />
    <link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">
    <script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>
    <script >hljs.initHighlightingOnLoad();</script>
    <style type="text/css">
        p{
            text-indent: 2em; /*em是相对单位，2em即现在一个字大小的两倍*/
        }
    </style>

</head>
<body>
<div id="header">
    <div class="overlay">
        <div class="container">
            <div class="row">
                <div class="col-md-4 logo-div">
                    <div class="logo-inner text-center">
                        <div class="logo-name">
                            <a href="/index.html">
                                <img src="/assets/img/me.jpg" class="img-circle" />
                            </a>
                        </div>

                    </div>

                </div>
                <div class="col-md-8 header-text-top " id="about">



                    <h1>刘佳兴的个人博客</h1>
                    记录我的学习历程。。。<br />
                    <h2>常见排序算法及实现</h2>
                    <h3>点击头像放回首页</h3>

                </div>
            </div>
        </div>
    </div>
</div>
<!--END HEADER SECTION-->
<div class="info-sec">
    <div class="container">
        <div class="row">
            <div class="col-md-10">
                <a href="/index.html">回到首页</a>
                <strong>联系我</strong>jiaixnglaw@163.com
            </div>
            <div class="col-md-2">
                <div class="social-link">
                    <a href="#" class="btn btn-default btn-xs">1<i class="fa fa-facebook fa-2x"></i></a>
                    <a href="#" class="btn btn-default btn-xs">2<i class="fa fa-linkedin fa-2x"></i></a>
                    <a href="#" class="btn btn-default btn-xs">3<i class="fa fa-google-plus fa-2x"></i></a>
                </div>

            </div>

        </div>
    </div>
</div>
<!--END INFO SECTION-->
<div class="container">

    <div class="row">

        <div class="col-md-8 ">
            <div class="blog-post">
                <!-- 放内容 -->
                <h4></h4>
                <p>
                    一般在面试中最常考的是快速排序和归并排序，并且经常有面试官要求现场写出这两种排序的代码。<br/>
                    对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。<br/>
                    面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。
                </p>
                <h4>快速排序</h4>
                <p>
                    快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。<br/>

                    算法步骤：<br/>

                    1 从数列中挑出一个元素，称为 “基准”（pivot），<br/>

                    2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br/>

                    3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br/>

                    递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
                </p>
                <pre>
                    <code>
                        public static void quickSort(int[] numbers, int start, int end) {
                             if (start < end) {
                             int base = numbers[start]; // 选定的基准值（第一个数值作为基准值）
                             int temp; // 记录临时中间值
                             int i = start, j = end;
                            do {
                                  while ((numbers[i] < base) && (i < end))
                                  i++;
                                  while ((numbers[j] > base) && (j > start))
                                  j--;
                                 if (i <= j) {
                                     temp = numbers[i];
                                     numbers[i] = numbers[j];
                                     numbers[j] = temp;
                                     i++;
                                     j--;
                                 }
                              } while (i <= j);
                             if (start < j)
                              quickSort(numbers, start, j);
                              if (end > i)
                              quickSort(numbers, i, end);
                             }
                        }
                    </code>
                </pre>
                <h4>冒泡排序</h4>
                <pre>
                    <code>
                        /**
                        * 冒泡排序
                        * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
                        * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
                        * 针对所有的元素重复以上的步骤，除了最后一个。
                        * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
                        * @param numbers 需要排序的整型数组
                        */
                        public static void bubbleSort(int[] numbers)
                        {
                            int temp = 0;
                            int size = numbers.length;
                            for(int i = 0 ; i < size-1; i ++)
                            {
                                for(int j = 0 ;j < size-1-i ; j++)
                                 {
                                     if(numbers[j] > numbers[j+1])  //交换两数位置
                                    {
                                       temp = numbers[j];
                                       numbers[j] = numbers[j+1];
                                       numbers[j+1] = temp;
                                     }
                                  }
                                 }
                        }
                    </code>
                </pre>
                <h4>堆排序</h4>
                <p>
                    堆是一种重要的数据结构，为一棵完全二叉树, 底层如果用数组存储数据的话，假设某个元素为序号为i(Java数组从0开始,i为0到n-1),<br/>
                    如果它有左子树，那么左子树的位置是2i+1，如果有右子树，右子树的位置是2i+2，如果有父节点，父节点的位置是(n-1)/2取整。<br/>
                    分为最大堆和最小堆，最大堆的任意子树根节点不小于任意子结点，最小堆的根节点不大于任意子结点。<br/>
                    利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大(或者最小)的记录。<br/>
                    也就是说，以最小堆为例，根节点为最小元素，较大的节点偏向于分布在堆底附近。
                </p>
                <pre>
                    <code>
                        public class HeapSort {
                        /**
                        * 堆筛选，除了start之外，start~end均满足大顶堆的定义。
                        * 调整之后start~end称为一个大顶堆。
                        * @param arr 待调整数组
                        * @param start 起始指针
                        * @param end 结束指针
                        */
                           public static void heapAdjust(int[] arr, int start, int end) {
                               int temp = arr[start];
                               for(int i=2*start+1; i<=end; i*=2) {
                                //左右孩子的节点分别为2*i+1,2*i+2
                                //选择出左右孩子较小的下标
                                   if(i < end && arr[i] < arr[i+1]) {
                                     i ++;
                                   }
                                   if(temp >= arr[i]) {
                                      break; //已经为大顶堆，=保持稳定性。
                                   }
                                   arr[start] = arr[i]; //将子节点上移
                                   start = i; //下一轮筛选
                                 }
                               arr[start] = temp; //插入正确的位置
                             }

                             public static void heapSort(int[] arr) {
                                if(arr == null || arr.length == 0)
                                 return ;

                                 //建立大顶堆
                                 for(int i=arr.length/2; i>=0; i--) {
                                     heapAdjust(arr, i, arr.length-1);
                                 }

                                 for(int i=arr.length-1; i>=0; i--) {
                                      swap(arr, 0, i);
                                      heapAdjust(arr, 0, i-1);
                                 }

                              }
                              public static void swap(int[] arr, int i, int j) {
                                 int temp = arr[i];
                                 arr[i] = arr[j];
                                 arr[j] = temp;
                                 }

                        }

                    </code>
                </pre>
                <h4>希尔排序</h4>
                <p>希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，
                    如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。
                    基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，
                    待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。</p>
                <img class="img-loc" src="/assets/img/blog201.jpgg">
                <pre>
                    <code>
                        public class ShellSort {
                        /**
                        * 希尔排序的一趟插入
                        * @param arr 待排数组
                        * @param d 增量*/
                        public static void shellInsert(int[] arr, int d)
                        {
                        for(int i=d; i<arr.length; i++)
                        {
                        int j = i - d;
                        int temp = arr[i];
                        //记录要插入的数据
                        while (j>=0 && arr[j]>temp) {
                        //从后向前，找到比其小的数的位置
                        arr[j+d] = arr[j]; //向后挪动
                        j -= d;
                        }
                        if (j != i - d)
                        //存在比其小的数
                        arr[j+d] = temp;
                        }
                        }
                        public static void shellSort(int[] arr)
                        {
                        if(arr == null || arr.length == 0)
                        return ;
                        int d = arr.length / 2;
                        while(d >= 1)
                        {
                        shellInsert(arr, d);
                        d /= 2;
                        }
                        }
                        }　　
                    </code>
                </pre>
            </div>

        </div>
        <div class="col-md-1"></div>
        <div class="col-md-3" style="padding-top: 30px;">
            <div class="row">
                <ul class="list-group">
                    <li class="list-group-item"><strong>分类</strong></li>
                    <li class="list-group-item">Java基础</li>
                    <li class="list-group-item">JAVA WEB</li>
                    <li class="list-group-item">数据库</li>
                    <li class="list-group-item">数据结构</li>
                    <li class="list-group-item">计算机网络</li>
                    <li class="list-group-item">面经</li>
                    <li class="list-group-item">设计模式</li>
                    <li class="list-group-item">杂</li>

                </ul>
            </div>
            <div class="row">
                <h3>Advertising</h3>


            </div>
        </div>

    </div>


</div>

<!--END HOME PAGE SECTION-->
<div class="footer-sec" style="margin-top: 0px;">
    <div class="container">
        <div class="row">
            <div class="col-md-12 foo-inner">
                &copy;  ljxxx.github.io
            </div>
        </div>
    </div>
</div>
<!-- END FOOTER SECTION -->
<!-- JAVASCRIPT FILES PLACED AT THE BOTTOM TO REDUCE THE LOADING TIME -->
<!-- CORE JQUERY -->
<script src="/assets/js/jquery-1.11.1.js"></script>
<!-- BOOTSTRAP SCRIPTS -->
<script src="/assets/js/bootstrap.js"></script>

</body>
</html>