<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="" />
    <meta name="author" content="" />
    <!--[if IE]>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <![endif]-->
    <title>Nice responsive template for blogger</title>
    <!-- BOOTSTRAP CORE STYLE -->
    <link href="/assets/css/bootstrap.css" rel="stylesheet" />
    <!-- FONT AWESOME ICON STYLE -->
    <link href="/assets/css/font-awesome.css" rel="stylesheet" />
    <!-- CUSTOM STYLE CSS -->
    <link href="/assets/css/style.css" rel="stylesheet" />
    <link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">
    <script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>
    <script >hljs.initHighlightingOnLoad();</script>
    <style type="text/css">
        p{
            text-indent: 2em; /*em是相对单位，2em即现在一个字大小的两倍*/
        }
    </style>

</head>
<body>
<div id="header">
    <div class="overlay">
        <div class="container">
            <div class="row">
                <div class="col-md-4 logo-div">
                    <div class="logo-inner text-center">
                        <div class="logo-name">
                            <a href="index.html">
                                <img src="/assets/img/me.jpg" class="img-circle" />
                            </a>
                        </div>

                    </div>

                </div>
                <div class="col-md-8 header-text-top " id="about">



                    <h1>刘佳兴的个人博客</h1>
                    记录我的学习历程。。。<br />
                    <h2><strong>Who I am ? </strong></h2>
                    <i>I am Jiaxing Liu </i>

                </div>
            </div>
        </div>
    </div>
</div>
<!--END HEADER SECTION-->
<div class="info-sec">
    <div class="container">
        <div class="row">
            <div class="col-md-10">
                 <strong>联系我</strong>jiaixnglaw@163.com
            </div>
            <div class="col-md-2">
                <div class="social-link">
                    <a href="#" class="btn btn-default btn-xs"><i class="fa fa-facebook fa-2x"></i></a>
                    <a href="#" class="btn btn-default btn-xs"><i class="fa fa-linkedin fa-2x"></i></a>
                    <a href="#" class="btn btn-default btn-xs"><i class="fa fa-google-plus fa-2x"></i></a>
                </div>

            </div>

        </div>
    </div>
</div>
<!--END INFO SECTION-->
<div class="container">

    <div class="row">

        <div class="col-md-8 ">
            <div class="blog-post">
                <!--设计模式学习20170410-->
                <h4>设计模式的六大原则</h4>
                <p>
                    1、开闭原则（Open Close Principle） <br/>

                    开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。
                    所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 <br/>

                    2、里氏代换原则（Liskov Substitution Principle） <br/>

                    里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。
                    里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。
                    LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
                    里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。
                    而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
                    —— From Baidu 百科 <br/>

                    3、依赖倒转原则（Dependence Inversion Principle） <br/>

                    这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 <br/>

                    4、接口隔离原则（Interface Segregation Principle） <br/>

                    这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。
                    还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，
                    从大型软件架构出发，为了升级和维护方便。
                    所以上文中多次出现：降低依赖，降低耦合。 <br/>

                    5、迪米特法则（最少知道原则）（Demeter Principle） <br/>

                    为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 <br/>

                    6、合成复用原则（Composite Reuse Principle） <br/>

                    原则是尽量使用合成/聚合的方式，而不是使用继承。 <br/>
                </p>
                <h4>简单工厂模式</h4>
                <p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的
                    实例，被创建的实例通常都具有共同的父类。 <br/>因为在简单工厂模式中用于创建实例的方法是
                    静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属
                    于类创建型模式</p>
                <img src="/assets/img/blog101.jpeg">
                <pre>
                    <code>
                        abstract class Product {
                         //所有产品类的公共业务方法
                            public void methodSame() {
                              //公共方法的实现
                              }
                          //声明抽象业务方法
                            public abstract void methodDiff();
                        }
                        //
                        class ConcreteProduct extends Product {
                         //实现业务方法
                             public void methodDiff() {
                              //业务方法的实现
                              }
                        }
                        //
                        class Factory {
                            //静态工厂方法
                            public static Product getProduct(String arg) {
                             Product product = null;
                             if (arg.equalsIgnoreCase("A")) {
                                 product = new ConcreteProductA();
                                //初始化设置product
                             }
                              else if (arg.equalsIgnoreCase("B")) {
                                product = new ConcreteProductB();
                                  //初始化设置product
                             }
                              return product;
                            }
                        }
                        //
                        class Client {
                              public static void main(String args[]) {
                              Product product;
                              product = Factory.getProduct("A"); //通过工厂类创建产品对象
                              product.methodSame();
                              product.methodDiff();
                              }
                        }
                    </code>
                </pre>
                <h4>工厂方法模式</h4>
                <p>普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建</p>
                <h4>策略模式</h4>
                <p></p>
                <h4>代理模式</h4>
                <p></p>
                <h4>装饰模式</h4>
                <p></p>
                <h4>原型模式</h4>
                <p></p>
                <h4>单例模式</h4> 
                <p>这一模式的目的是使得类的一个对象成为系统中的唯一实例。  要实现这一点，可以从客户端对其进行实例化开始。 
                    因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过程。 
                    这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义。 <br/>
                    &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
                    单例模式的要点有三个；<br/> 
                    一是某个类只能有一个实例；<br/> 
                    二是它必须自行创建这个实例；<br/> 
                    三是它必须自行向整个系统提供这个实例<br/> 
                </p> 
                <pre> 
                    模式1:懒汉式 
                    <code> 
                        public class SingletonClass{ 
                            private static volatile SingletonClass instance=null; 
                                public static SingletonClass getInstance(){ 
                                    synchronized(SingletonClass.class){ 
                                        if(instance==null){ 
                                         instance=new SingletonClass(); 
                                           } 
                                        } 
                                     return instance; 
                                } 
                            private SingletonClass(){} 
                        } 
                    </code> 
                    模式2:饿汉式
                    <code>
                        public class Singleton{
                        //在自己内部定义自己的一个实例，只供内部调用
                         private static final Singleton instance = new Singleton();
                             private Singleton(){
                                 //do something
                             }
                        //这里提供了一个供外部访问本class的静态方法，可以直接访问
                            public static Singleton getInstance(){
                             return instance;
                             }
                        }
                    </code>
                    模式3:双重锁式
                    <code>
                        public class Singleton{
                            private static volatile Singleton instance=null;
                                private Singleton(){
                                 //do something
                                 }
                            public static  Singleton getInstance(){
                                 if(instance==null){
                                    synchronized(SingletonClass.class){
                                        if(instance==null){
                                            instance=new Singleton();
                                         }
                                     }
                                    }
                                return instance;
                             }
                        }

                    </code>
                </pre>


            </div>

            <br />

        </div>
        <div class="col-md-1"></div>
        <div class="col-md-3" style="padding-top: 30px;">
            <div class="row">
                <ul class="list-group">
                    <li class="list-group-item"><strong>CATEGORIES</strong></li>
                    <li class="list-group-item">Dapibus ac facilisis in</li>
                    <li class="list-group-item">Morbi leo risus</li>
                    <li class="list-group-item">Porta ac consectetur ac</li>
                    <li class="list-group-item">Vestibulum at eros</li>
                    <li class="list-group-item">Dapibus ac facilisis in</li>
                    <li class="list-group-item">Morbi leo risus</li>
                    <li class="list-group-item">Porta ac consectetur ac</li>
                    <li class="list-group-item">Vestibulum at eros</li>
                </ul>
            </div>
            <div class="row">
                <h3>Advertising</h3>


            </div>
        </div>

    </div>


</div>

<!--END HOME PAGE SECTION-->
<div class="footer-sec" style="margin-top: 0px;">
    <div class="container">
        <div class="row">
            <div class="col-md-12 foo-inner">
                &copy;  ljxxx.github.io
            </div>
        </div>
    </div>
</div>
<!-- END FOOTER SECTION -->
<!-- JAVASCRIPT FILES PLACED AT THE BOTTOM TO REDUCE THE LOADING TIME -->
<!-- CORE JQUERY -->
<script src="/assets/js/jquery-1.11.1.js"></script>
<!-- BOOTSTRAP SCRIPTS -->
<script src="/assets/js/bootstrap.js"></script>

</body>
</html>
